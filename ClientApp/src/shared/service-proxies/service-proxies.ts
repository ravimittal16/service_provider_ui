/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param externalLoginId (optional) 
     * @param userEmail (optional) 
     * @return Success
     */
    externalLogin(externalLoginId: string | null | undefined, userEmail: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogin?";
        if (externalLoginId !== undefined && externalLoginId !== null)
            url_ += "externalLoginId=" + encodeURIComponent("" + externalLoginId) + "&";
        if (userEmail !== undefined && userEmail !== null)
            url_ += "userEmail=" + encodeURIComponent("" + userEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterModel | undefined): Observable<RegisterModelGenericResponse> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterModelGenericResponse>(<any>null);
    }

    /**
     * @return Success
     */
    intuitSignIn(): Observable<void> {
        let url_ = this.baseUrl + "/api/Account/IntuitSignIn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntuitSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntuitSignIn(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processIntuitSignIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param signupKey (optional) 
     * @return Success
     */
    getExternalSignupModel(signupKey: string | null | undefined): Observable<RegisterModelGenericResponse> {
        let url_ = this.baseUrl + "/api/Account/GetExternalSignupModel?";
        if (signupKey !== undefined && signupKey !== null)
            url_ += "signupKey=" + encodeURIComponent("" + signupKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalSignupModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalSignupModel(<any>response_);
                } catch (e) {
                    return <Observable<RegisterModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalSignupModel(response: HttpResponseBase): Observable<RegisterModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterModelGenericResponse>(<any>null);
    }
}

@Injectable()
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCompanyDetails(): Observable<CompanyDetailsModel> {
        let url_ = this.baseUrl + "/api/company/GetCompanyDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyDetails(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDetailsModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDetailsModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyDetails(response: HttpResponseBase): Observable<CompanyDetailsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDetailsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDetailsModel>(<any>null);
    }

    /**
     * @return Success
     */
    getApplicationData(): Observable<CommonDataModel> {
        let url_ = this.baseUrl + "/api/company/GetApplicationData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationData(<any>response_);
                } catch (e) {
                    return <Observable<CommonDataModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonDataModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationData(response: HttpResponseBase): Observable<CommonDataModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonDataModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonDataModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCompany(body: CompanyDetailsModel | undefined): Observable<CompanyDetailsModelGenericResponse> {
        let url_ = this.baseUrl + "/api/company/UpdateCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompany(<any>response_);
                } catch (e) {
                    return <Observable<CompanyDetailsModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyDetailsModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCompany(response: HttpResponseBase): Observable<CompanyDetailsModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDetailsModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDetailsModelGenericResponse>(<any>null);
    }

    /**
     * @param countryCode (optional) 
     * @return Success
     */
    getTimezonesList(countryCode: string | null | undefined): Observable<TimezoneModel[]> {
        let url_ = this.baseUrl + "/api/company/GetTimezonesList?";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezonesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezonesList(<any>response_);
                } catch (e) {
                    return <Observable<TimezoneModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TimezoneModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezonesList(response: HttpResponseBase): Observable<TimezoneModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TimezoneModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimezoneModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscribedFeature(): Observable<SubscribedFeaturesDto[]> {
        let url_ = this.baseUrl + "/api/company/GetSubscribedFeature";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscribedFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscribedFeature(<any>response_);
                } catch (e) {
                    return <Observable<SubscribedFeaturesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribedFeaturesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscribedFeature(response: HttpResponseBase): Observable<SubscribedFeaturesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubscribedFeaturesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribedFeaturesDto[]>(<any>null);
    }

    /**
     * @param featureId (optional) 
     * @param activate (optional) 
     * @return Success
     */
    activateDeactivateFeature(featureId: number | undefined, activate: boolean | undefined): Observable<OperationResult> {
        let url_ = this.baseUrl + "/api/company/ActivateDeactivateFeature?";
        if (featureId === null)
            throw new Error("The parameter 'featureId' cannot be null.");
        else if (featureId !== undefined)
            url_ += "featureId=" + encodeURIComponent("" + featureId) + "&";
        if (activate === null)
            throw new Error("The parameter 'activate' cannot be null.");
        else if (activate !== undefined)
            url_ += "activate=" + encodeURIComponent("" + activate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateDeactivateFeature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateDeactivateFeature(<any>response_);
                } catch (e) {
                    return <Observable<OperationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OperationResult>><any>_observableThrow(response_);
        }));
    }

    protected processActivateDeactivateFeature(response: HttpResponseBase): Observable<OperationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationResult>(<any>null);
    }
}

@Injectable()
export class CustomersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUpdateCustomer(body: CustomerModel | undefined): Observable<CustomerModelGenericResponse> {
        let url_ = this.baseUrl + "/api/Customers/CreateUpdateCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUpdateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUpdateCustomer(<any>response_);
                } catch (e) {
                    return <Observable<CustomerModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUpdateCustomer(response: HttpResponseBase): Observable<CustomerModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerModelGenericResponse>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerEditDetails(customerId: number | undefined): Observable<CustomerDetailModel> {
        let url_ = this.baseUrl + "/api/Customers/GetCustomerEditDetails?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerEditDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerEditDetails(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDetailModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDetailModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerEditDetails(response: HttpResponseBase): Observable<CustomerDetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDetailModel>(<any>null);
    }

    /**
     * @return Success
     */
    importCustomers(): Observable<DataImportResponseModel[]> {
        let url_ = this.baseUrl + "/api/Customers/ImportCustomers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportCustomers(<any>response_);
                } catch (e) {
                    return <Observable<DataImportResponseModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataImportResponseModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processImportCustomers(response: HttpResponseBase): Observable<DataImportResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataImportResponseModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataImportResponseModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCustomers(): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/Customers/GetAllCustomers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomers(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomers(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto[]>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerAddress(customerId: number | undefined): Observable<AddressDto[]> {
        let url_ = this.baseUrl + "/api/Customers/GetCustomerAddress?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAddress(<any>response_);
                } catch (e) {
                    return <Observable<AddressDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerAddress(response: HttpResponseBase): Observable<AddressDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AddressDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deactiveCustomers(body: BatchActionRequestModel | undefined): Observable<BatchActionRequestModelGenericResponse> {
        let url_ = this.baseUrl + "/api/Customers/DeactiveCustomers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactiveCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactiveCustomers(<any>response_);
                } catch (e) {
                    return <Observable<BatchActionRequestModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BatchActionRequestModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeactiveCustomers(response: HttpResponseBase): Observable<BatchActionRequestModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BatchActionRequestModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BatchActionRequestModelGenericResponse>(<any>null);
    }
}

@Injectable()
export class CustomFieldsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateCustomField(body: CustomFieldDefinationModel | undefined): Observable<CustomFieldDefinationModelGenericResponse> {
        let url_ = this.baseUrl + "/api/customFields/AddUpdateCustomField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateCustomField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateCustomField(<any>response_);
                } catch (e) {
                    return <Observable<CustomFieldDefinationModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomFieldDefinationModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateCustomField(response: HttpResponseBase): Observable<CustomFieldDefinationModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldDefinationModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomFieldDefinationModelGenericResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCustomFieldTypes(): Observable<CustomFieldTypesResult> {
        let url_ = this.baseUrl + "/api/customFields/GetAllCustomFieldTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomFieldTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomFieldTypes(<any>response_);
                } catch (e) {
                    return <Observable<CustomFieldTypesResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomFieldTypesResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomFieldTypes(response: HttpResponseBase): Observable<CustomFieldTypesResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldTypesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomFieldTypesResult>(<any>null);
    }
}

@Injectable()
export class ExpenseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpenseCode(body: ExpenseCodeModel | undefined): Observable<ExpenseCodeModelGenericResponse> {
        let url_ = this.baseUrl + "/api/expense/AddUpdateExpenseCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpenseCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpenseCode(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseCodeModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseCodeModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpenseCode(response: HttpResponseBase): Observable<ExpenseCodeModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseCodeModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseCodeModelGenericResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUpdateExpense(body: CreateExpenseModel | undefined): Observable<ExpenseDtoGenericResponse> {
        let url_ = this.baseUrl + "/api/expense/AddUpdateExpense";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateExpense(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDtoGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDtoGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateExpense(response: HttpResponseBase): Observable<ExpenseDtoGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDtoGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDtoGenericResponse>(<any>null);
    }

    /**
     * @param jobId (optional) 
     * @return Success
     */
    getAllExpenses(jobId: number | undefined): Observable<ExpenseDto[]> {
        let url_ = this.baseUrl + "/api/expense/GetAllExpenses?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllExpenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllExpenses(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllExpenses(response: HttpResponseBase): Observable<ExpenseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExpenseDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getExpenseCodes(): Observable<ExpenseCodeModel[]> {
        let url_ = this.baseUrl + "/api/expense/GetExpenseCodes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpenseCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpenseCodes(<any>response_);
                } catch (e) {
                    return <Observable<ExpenseCodeModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpenseCodeModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpenseCodes(response: HttpResponseBase): Observable<ExpenseCodeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExpenseCodeModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseCodeModel[]>(<any>null);
    }
}

@Injectable()
export class JobFormsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllFormDefinations(): Observable<JobFormDefinationDto[]> {
        let url_ = this.baseUrl + "/api/JobForms/GetAllFormDefinations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFormDefinations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFormDefinations(<any>response_);
                } catch (e) {
                    return <Observable<JobFormDefinationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobFormDefinationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFormDefinations(response: HttpResponseBase): Observable<JobFormDefinationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(JobFormDefinationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobFormDefinationDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createJobForm(body: JobFormModel | undefined): Observable<JobFormModelGenericResponse> {
        let url_ = this.baseUrl + "/api/JobForms/CreateJobForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJobForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJobForm(<any>response_);
                } catch (e) {
                    return <Observable<JobFormModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobFormModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJobForm(response: HttpResponseBase): Observable<JobFormModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFormModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobFormModelGenericResponse>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @return Success
     */
    deleteJobFormDefination(formId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/JobForms/DeleteJobFormDefination?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJobFormDefination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJobFormDefination(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJobFormDefination(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @return Success
     */
    getFormDetails(formId: number | undefined): Observable<JobFormModelGenericResponse> {
        let url_ = this.baseUrl + "/api/JobForms/GetFormDetails?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFormDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFormDetails(<any>response_);
                } catch (e) {
                    return <Observable<JobFormModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobFormModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetFormDetails(response: HttpResponseBase): Observable<JobFormModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFormModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobFormModelGenericResponse>(<any>null);
    }

    /**
     * @param sectionId (optional) 
     * @return Success
     */
    deleteJobFormSection(sectionId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/JobForms/DeleteJobFormSection?";
        if (sectionId === null)
            throw new Error("The parameter 'sectionId' cannot be null.");
        else if (sectionId !== undefined)
            url_ += "sectionId=" + encodeURIComponent("" + sectionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJobFormSection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJobFormSection(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteJobFormSection(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param formId (optional) 
     * @param jobId (optional) 
     * @return Success
     */
    attachJobFormToJob(formId: number | undefined, jobId: number | undefined): Observable<OperationResult> {
        let url_ = this.baseUrl + "/api/JobForms/AttachJobFormToJob?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachJobFormToJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachJobFormToJob(<any>response_);
                } catch (e) {
                    return <Observable<OperationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OperationResult>><any>_observableThrow(response_);
        }));
    }

    protected processAttachJobFormToJob(response: HttpResponseBase): Observable<OperationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationResult>(<any>null);
    }

    /**
     * @param jobId (optional) 
     * @param formId (optional) 
     * @param recordId (optional) 
     * @return Success
     */
    getJobFormData(jobId: number | undefined, formId: number | undefined, recordId: number | undefined): Observable<JobFormDataDetailSingleGenericResponse> {
        let url_ = this.baseUrl + "/api/JobForms/GetJobFormData?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&";
        if (recordId === null)
            throw new Error("The parameter 'recordId' cannot be null.");
        else if (recordId !== undefined)
            url_ += "recordId=" + encodeURIComponent("" + recordId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobFormData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobFormData(<any>response_);
                } catch (e) {
                    return <Observable<JobFormDataDetailSingleGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobFormDataDetailSingleGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobFormData(response: HttpResponseBase): Observable<JobFormDataDetailSingleGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFormDataDetailSingleGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobFormDataDetailSingleGenericResponse>(<any>null);
    }
}

@Injectable()
export class JobsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createJob(body: CreateJobModel | undefined): Observable<CreateJobModelGenericResponse> {
        let url_ = this.baseUrl + "/api/Jobs/CreateJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJob(<any>response_);
                } catch (e) {
                    return <Observable<CreateJobModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateJobModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJob(response: HttpResponseBase): Observable<CreateJobModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateJobModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateJobModelGenericResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createJobVisit(body: CreateJobVisitModel | undefined): Observable<JobVisitDtoGenericResponse> {
        let url_ = this.baseUrl + "/api/Jobs/CreateJobVisit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJobVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJobVisit(<any>response_);
                } catch (e) {
                    return <Observable<JobVisitDtoGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobVisitDtoGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJobVisit(response: HttpResponseBase): Observable<JobVisitDtoGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobVisitDtoGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobVisitDtoGenericResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getJobs(body: JobFilterModel | undefined): Observable<JobDto[]> {
        let url_ = this.baseUrl + "/api/Jobs/GetJobs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobs(<any>response_);
                } catch (e) {
                    return <Observable<JobDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobs(response: HttpResponseBase): Observable<JobDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(JobDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDto[]>(<any>null);
    }

    /**
     * @param jobId (optional) 
     * @return Success
     */
    getJobDetails(jobId: number | undefined): Observable<JobDetailsDto> {
        let url_ = this.baseUrl + "/api/Jobs/GetJobDetails?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobDetails(<any>response_);
                } catch (e) {
                    return <Observable<JobDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobDetails(response: HttpResponseBase): Observable<JobDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDetailsDto>(<any>null);
    }

    /**
     * @param jobId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addUpdateLineItem(jobId: number | undefined, body: ProductDto | undefined): Observable<JobLineItemDto> {
        let url_ = this.baseUrl + "/api/Jobs/AddUpdateLineItem?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateLineItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateLineItem(<any>response_);
                } catch (e) {
                    return <Observable<JobLineItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobLineItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddUpdateLineItem(response: HttpResponseBase): Observable<JobLineItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobLineItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobLineItemDto>(<any>null);
    }

    /**
     * @param jobId (optional) 
     * @param itemId (optional) 
     * @return Success
     */
    deleteLineItem(jobId: number | undefined, itemId: number | undefined): Observable<OperationResult> {
        let url_ = this.baseUrl + "/api/Jobs/DeleteLineItem?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLineItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLineItem(<any>response_);
                } catch (e) {
                    return <Observable<OperationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OperationResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLineItem(response: HttpResponseBase): Observable<OperationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationResult>(<any>null);
    }

    /**
     * @param jobId (optional) 
     * @param visitId (optional) 
     * @param deleteItems (optional) 
     * @return Success
     */
    deleteVisit(jobId: number | undefined, visitId: number | undefined, deleteItems: boolean | undefined): Observable<OperationResult> {
        let url_ = this.baseUrl + "/api/Jobs/DeleteVisit?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        if (visitId === null)
            throw new Error("The parameter 'visitId' cannot be null.");
        else if (visitId !== undefined)
            url_ += "visitId=" + encodeURIComponent("" + visitId) + "&";
        if (deleteItems === null)
            throw new Error("The parameter 'deleteItems' cannot be null.");
        else if (deleteItems !== undefined)
            url_ += "deleteItems=" + encodeURIComponent("" + deleteItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVisit(<any>response_);
                } catch (e) {
                    return <Observable<OperationResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<OperationResult>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVisit(response: HttpResponseBase): Observable<OperationResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OperationResult>(<any>null);
    }

    /**
     * @param jobId (optional) 
     * @param visitId (optional) 
     * @return Success
     */
    markVisitAsCompleted(jobId: number | undefined, visitId: number | undefined): Observable<JobVisitDtoGenericResponse> {
        let url_ = this.baseUrl + "/api/Jobs/MarkVisitAsCompleted?";
        if (jobId === null)
            throw new Error("The parameter 'jobId' cannot be null.");
        else if (jobId !== undefined)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        if (visitId === null)
            throw new Error("The parameter 'visitId' cannot be null.");
        else if (visitId !== undefined)
            url_ += "visitId=" + encodeURIComponent("" + visitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkVisitAsCompleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkVisitAsCompleted(<any>response_);
                } catch (e) {
                    return <Observable<JobVisitDtoGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobVisitDtoGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMarkVisitAsCompleted(response: HttpResponseBase): Observable<JobVisitDtoGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobVisitDtoGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobVisitDtoGenericResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addJobNote(body: CreateJobNoteModel | undefined): Observable<JobNoteDtoGenericResponse> {
        let url_ = this.baseUrl + "/api/Jobs/AddJobNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddJobNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddJobNote(<any>response_);
                } catch (e) {
                    return <Observable<JobNoteDtoGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobNoteDtoGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddJobNote(response: HttpResponseBase): Observable<JobNoteDtoGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobNoteDtoGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobNoteDtoGenericResponse>(<any>null);
    }
}

@Injectable()
export class ProductsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importProducts(): Observable<DataImportResponseModel[]> {
        let url_ = this.baseUrl + "/api/Products/ImportProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportProducts(<any>response_);
                } catch (e) {
                    return <Observable<DataImportResponseModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataImportResponseModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processImportProducts(response: HttpResponseBase): Observable<DataImportResponseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataImportResponseModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataImportResponseModel[]>(<any>null);
    }

    /**
     * @param filterBy (optional) 
     * @return Success
     */
    getAllProducts(filterBy: string | null | undefined): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Products/GetAllProducts?";
        if (filterBy !== undefined && filterBy !== null)
            url_ += "filterBy=" + encodeURIComponent("" + filterBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProducts(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto[]>(<any>null);
    }
}

@Injectable()
export class UsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllUsers(): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/Users/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEmployees(): Observable<EmployeeDto[]> {
        let url_ = this.baseUrl + "/api/Users/GetAllEmployees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployees(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployees(response: HttpResponseBase): Observable<EmployeeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(EmployeeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTeams(): Observable<TeamDto[]> {
        let url_ = this.baseUrl + "/api/Users/GetAllTeams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTeams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTeams(<any>response_);
                } catch (e) {
                    return <Observable<TeamDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TeamDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTeams(response: HttpResponseBase): Observable<TeamDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TeamDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TeamDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUser(body: CreateUserModel | undefined): Observable<CreateUserModelGenericResponse> {
        let url_ = this.baseUrl + "/api/Users/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<CreateUserModelGenericResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateUserModelGenericResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<CreateUserModelGenericResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUserModelGenericResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUserModelGenericResponse>(<any>null);
    }
}

@Injectable()
export class WeatherForecastServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: string | undefined;
}

export class RegisterModel implements IRegisterModel {
    userName: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    companyName: string | undefined;
    phoneNumber: string | undefined;
    externalSignupId: string | undefined;
    externalLoginKey: string | undefined;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.companyName = _data["companyName"];
            this.phoneNumber = _data["phoneNumber"];
            this.externalSignupId = _data["externalSignupId"];
            this.externalLoginKey = _data["externalLoginKey"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["companyName"] = this.companyName;
        data["phoneNumber"] = this.phoneNumber;
        data["externalSignupId"] = this.externalSignupId;
        data["externalLoginKey"] = this.externalLoginKey;
        return data; 
    }

    clone(): RegisterModel {
        const json = this.toJSON();
        let result = new RegisterModel();
        result.init(json);
        return result;
    }
}

export interface IRegisterModel {
    userName: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    companyName: string | undefined;
    phoneNumber: string | undefined;
    externalSignupId: string | undefined;
    externalLoginKey: string | undefined;
}

export enum ErrorTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum CodeType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ActionReturnCode implements IActionReturnCode {
    code: number;
    message: string | undefined;
    codeType: CodeType;
    clientMessage: string | undefined;

    constructor(data?: IActionReturnCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.codeType = _data["codeType"];
            this.clientMessage = _data["clientMessage"];
        }
    }

    static fromJS(data: any): ActionReturnCode {
        data = typeof data === 'object' ? data : {};
        let result = new ActionReturnCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["codeType"] = this.codeType;
        data["clientMessage"] = this.clientMessage;
        return data; 
    }

    clone(): ActionReturnCode {
        const json = this.toJSON();
        let result = new ActionReturnCode();
        result.init(json);
        return result;
    }
}

export interface IActionReturnCode {
    code: number;
    message: string | undefined;
    codeType: CodeType;
    clientMessage: string | undefined;
}

export class RegisterModelGenericResponse implements IRegisterModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: RegisterModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IRegisterModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? RegisterModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RegisterModelGenericResponse {
        const json = this.toJSON();
        let result = new RegisterModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IRegisterModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: RegisterModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export enum Weekdays {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum PropertyTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class AddressDto implements IAddressDto {
    propertyType: PropertyTypes;
    readonly propertyName: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    countrySubDivisionCode: string | undefined;
    country: string | undefined;
    postalCode: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    isPrimary: boolean | undefined;
    readonly formattedAddress: string | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyType = _data["propertyType"];
            (<any>this).propertyName = _data["propertyName"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.countrySubDivisionCode = _data["countrySubDivisionCode"];
            this.country = _data["country"];
            this.postalCode = _data["postalCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.isPrimary = _data["isPrimary"];
            (<any>this).formattedAddress = _data["formattedAddress"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyType"] = this.propertyType;
        data["propertyName"] = this.propertyName;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["countrySubDivisionCode"] = this.countrySubDivisionCode;
        data["country"] = this.country;
        data["postalCode"] = this.postalCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["isPrimary"] = this.isPrimary;
        data["formattedAddress"] = this.formattedAddress;
        return data; 
    }

    clone(): AddressDto {
        const json = this.toJSON();
        let result = new AddressDto();
        result.init(json);
        return result;
    }
}

export interface IAddressDto {
    propertyType: PropertyTypes;
    propertyName: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    city: string | undefined;
    countrySubDivisionCode: string | undefined;
    country: string | undefined;
    postalCode: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    isPrimary: boolean | undefined;
    formattedAddress: string | undefined;
}

export class CompanyBusinessHourModel implements ICompanyBusinessHourModel {
    businessHourId: number;
    dayOfWeek: Weekdays;
    startTime: moment.Moment | undefined;
    finishTime: moment.Moment | undefined;
    isClosed: boolean | undefined;
    readonly dayName: string | undefined;

    constructor(data?: ICompanyBusinessHourModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessHourId = _data["businessHourId"];
            this.dayOfWeek = _data["dayOfWeek"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.finishTime = _data["finishTime"] ? moment(_data["finishTime"].toString()) : <any>undefined;
            this.isClosed = _data["isClosed"];
            (<any>this).dayName = _data["dayName"];
        }
    }

    static fromJS(data: any): CompanyBusinessHourModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyBusinessHourModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessHourId"] = this.businessHourId;
        data["dayOfWeek"] = this.dayOfWeek;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["finishTime"] = this.finishTime ? this.finishTime.toISOString() : <any>undefined;
        data["isClosed"] = this.isClosed;
        data["dayName"] = this.dayName;
        return data; 
    }

    clone(): CompanyBusinessHourModel {
        const json = this.toJSON();
        let result = new CompanyBusinessHourModel();
        result.init(json);
        return result;
    }
}

export interface ICompanyBusinessHourModel {
    businessHourId: number;
    dayOfWeek: Weekdays;
    startTime: moment.Moment | undefined;
    finishTime: moment.Moment | undefined;
    isClosed: boolean | undefined;
    dayName: string | undefined;
}

export class TaxRateModel implements ITaxRateModel {
    taxRateId: number;
    rateValue: number | undefined;
    name: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    taxCodeId: number | undefined;

    constructor(data?: ITaxRateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taxRateId = _data["taxRateId"];
            this.rateValue = _data["rateValue"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            this.taxCodeId = _data["taxCodeId"];
        }
    }

    static fromJS(data: any): TaxRateModel {
        data = typeof data === 'object' ? data : {};
        let result = new TaxRateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxRateId"] = this.taxRateId;
        data["rateValue"] = this.rateValue;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        data["taxCodeId"] = this.taxCodeId;
        return data; 
    }

    clone(): TaxRateModel {
        const json = this.toJSON();
        let result = new TaxRateModel();
        result.init(json);
        return result;
    }
}

export interface ITaxRateModel {
    taxRateId: number;
    rateValue: number | undefined;
    name: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    taxCodeId: number | undefined;
}

export class CompanyDetailsModel implements ICompanyDetailsModel {
    companyName: string | undefined;
    country: string | undefined;
    email: string | undefined;
    webAddr: string | undefined;
    primaryPhone: string | undefined;
    firstDayOfWeek: Weekdays;
    dateFormat: string | undefined;
    timeFormat: string | undefined;
    timeZoneStandardName: string | undefined;
    compAddresses: AddressDto[] | undefined;
    businessHourModels: CompanyBusinessHourModel[] | undefined;
    taxRates: TaxRateModel[] | undefined;

    constructor(data?: ICompanyDetailsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.country = _data["country"];
            this.email = _data["email"];
            this.webAddr = _data["webAddr"];
            this.primaryPhone = _data["primaryPhone"];
            this.firstDayOfWeek = _data["firstDayOfWeek"];
            this.dateFormat = _data["dateFormat"];
            this.timeFormat = _data["timeFormat"];
            this.timeZoneStandardName = _data["timeZoneStandardName"];
            if (Array.isArray(_data["compAddresses"])) {
                this.compAddresses = [] as any;
                for (let item of _data["compAddresses"])
                    this.compAddresses.push(AddressDto.fromJS(item));
            }
            if (Array.isArray(_data["businessHourModels"])) {
                this.businessHourModels = [] as any;
                for (let item of _data["businessHourModels"])
                    this.businessHourModels.push(CompanyBusinessHourModel.fromJS(item));
            }
            if (Array.isArray(_data["taxRates"])) {
                this.taxRates = [] as any;
                for (let item of _data["taxRates"])
                    this.taxRates.push(TaxRateModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyDetailsModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDetailsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["country"] = this.country;
        data["email"] = this.email;
        data["webAddr"] = this.webAddr;
        data["primaryPhone"] = this.primaryPhone;
        data["firstDayOfWeek"] = this.firstDayOfWeek;
        data["dateFormat"] = this.dateFormat;
        data["timeFormat"] = this.timeFormat;
        data["timeZoneStandardName"] = this.timeZoneStandardName;
        if (Array.isArray(this.compAddresses)) {
            data["compAddresses"] = [];
            for (let item of this.compAddresses)
                data["compAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.businessHourModels)) {
            data["businessHourModels"] = [];
            for (let item of this.businessHourModels)
                data["businessHourModels"].push(item.toJSON());
        }
        if (Array.isArray(this.taxRates)) {
            data["taxRates"] = [];
            for (let item of this.taxRates)
                data["taxRates"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CompanyDetailsModel {
        const json = this.toJSON();
        let result = new CompanyDetailsModel();
        result.init(json);
        return result;
    }
}

export interface ICompanyDetailsModel {
    companyName: string | undefined;
    country: string | undefined;
    email: string | undefined;
    webAddr: string | undefined;
    primaryPhone: string | undefined;
    firstDayOfWeek: Weekdays;
    dateFormat: string | undefined;
    timeFormat: string | undefined;
    timeZoneStandardName: string | undefined;
    compAddresses: AddressDto[] | undefined;
    businessHourModels: CompanyBusinessHourModel[] | undefined;
    taxRates: TaxRateModel[] | undefined;
}

export class LookupValueModel implements ILookupValueModel {
    lookUpValueId: number;
    keyName: string | undefined;
    value: string | undefined;
    type: string | undefined;

    constructor(data?: ILookupValueModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookUpValueId = _data["lookUpValueId"];
            this.keyName = _data["keyName"];
            this.value = _data["value"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): LookupValueModel {
        data = typeof data === 'object' ? data : {};
        let result = new LookupValueModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookUpValueId"] = this.lookUpValueId;
        data["keyName"] = this.keyName;
        data["value"] = this.value;
        data["type"] = this.type;
        return data; 
    }

    clone(): LookupValueModel {
        const json = this.toJSON();
        let result = new LookupValueModel();
        result.init(json);
        return result;
    }
}

export interface ILookupValueModel {
    lookUpValueId: number;
    keyName: string | undefined;
    value: string | undefined;
    type: string | undefined;
}

export class CountryModel implements ICountryModel {
    countryId: number;
    countryName: string | undefined;
    countryCode: string | undefined;
    readonly formattedValue: string | undefined;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.countryCode = _data["countryCode"];
            (<any>this).formattedValue = _data["formattedValue"];
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["countryCode"] = this.countryCode;
        data["formattedValue"] = this.formattedValue;
        return data; 
    }

    clone(): CountryModel {
        const json = this.toJSON();
        let result = new CountryModel();
        result.init(json);
        return result;
    }
}

export interface ICountryModel {
    countryId: number;
    countryName: string | undefined;
    countryCode: string | undefined;
    formattedValue: string | undefined;
}

export class TimezoneModel implements ITimezoneModel {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: ITimezoneModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TimezoneModel {
        data = typeof data === 'object' ? data : {};
        let result = new TimezoneModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): TimezoneModel {
        const json = this.toJSON();
        let result = new TimezoneModel();
        result.init(json);
        return result;
    }
}

export interface ITimezoneModel {
    name: string | undefined;
    value: string | undefined;
}

export class CommonDataModel implements ICommonDataModel {
    lookupValues: LookupValueModel[] | undefined;
    countries: CountryModel[] | undefined;
    timeZones: TimezoneModel[] | undefined;

    constructor(data?: ICommonDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lookupValues"])) {
                this.lookupValues = [] as any;
                for (let item of _data["lookupValues"])
                    this.lookupValues.push(LookupValueModel.fromJS(item));
            }
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries.push(CountryModel.fromJS(item));
            }
            if (Array.isArray(_data["timeZones"])) {
                this.timeZones = [] as any;
                for (let item of _data["timeZones"])
                    this.timeZones.push(TimezoneModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommonDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommonDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lookupValues)) {
            data["lookupValues"] = [];
            for (let item of this.lookupValues)
                data["lookupValues"].push(item.toJSON());
        }
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        if (Array.isArray(this.timeZones)) {
            data["timeZones"] = [];
            for (let item of this.timeZones)
                data["timeZones"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CommonDataModel {
        const json = this.toJSON();
        let result = new CommonDataModel();
        result.init(json);
        return result;
    }
}

export interface ICommonDataModel {
    lookupValues: LookupValueModel[] | undefined;
    countries: CountryModel[] | undefined;
    timeZones: TimezoneModel[] | undefined;
}

export class CompanyDetailsModelGenericResponse implements ICompanyDetailsModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: CompanyDetailsModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: ICompanyDetailsModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? CompanyDetailsModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyDetailsModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDetailsModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CompanyDetailsModelGenericResponse {
        const json = this.toJSON();
        let result = new CompanyDetailsModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface ICompanyDetailsModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: CompanyDetailsModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export enum EntityStatuses {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    __1 = -1,
}

export class SubscribedFeaturesDto implements ISubscribedFeaturesDto {
    featureId: number;
    id: number;
    companyId: number;
    subscriptonId: number;
    entityStatus: EntityStatuses;

    constructor(data?: ISubscribedFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.featureId = _data["featureId"];
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.subscriptonId = _data["subscriptonId"];
            this.entityStatus = _data["entityStatus"];
        }
    }

    static fromJS(data: any): SubscribedFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribedFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["featureId"] = this.featureId;
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["subscriptonId"] = this.subscriptonId;
        data["entityStatus"] = this.entityStatus;
        return data; 
    }

    clone(): SubscribedFeaturesDto {
        const json = this.toJSON();
        let result = new SubscribedFeaturesDto();
        result.init(json);
        return result;
    }
}

export interface ISubscribedFeaturesDto {
    featureId: number;
    id: number;
    companyId: number;
    subscriptonId: number;
    entityStatus: EntityStatuses;
}

export class OperationResult implements IOperationResult {
    isSuccess: boolean;
    isWarning: boolean;
    errors: string[] | undefined;
    warnings: string[] | undefined;
    clientMessages: string[] | undefined;
    returnCode: ActionReturnCode;

    constructor(data?: IOperationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.isWarning = _data["isWarning"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings.push(item);
            }
            if (Array.isArray(_data["clientMessages"])) {
                this.clientMessages = [] as any;
                for (let item of _data["clientMessages"])
                    this.clientMessages.push(item);
            }
            this.returnCode = _data["returnCode"] ? ActionReturnCode.fromJS(_data["returnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OperationResult {
        data = typeof data === 'object' ? data : {};
        let result = new OperationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["isWarning"] = this.isWarning;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        if (Array.isArray(this.clientMessages)) {
            data["clientMessages"] = [];
            for (let item of this.clientMessages)
                data["clientMessages"].push(item);
        }
        data["returnCode"] = this.returnCode ? this.returnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): OperationResult {
        const json = this.toJSON();
        let result = new OperationResult();
        result.init(json);
        return result;
    }
}

export interface IOperationResult {
    isSuccess: boolean;
    isWarning: boolean;
    errors: string[] | undefined;
    warnings: string[] | undefined;
    clientMessages: string[] | undefined;
    returnCode: ActionReturnCode;
}

export class CustomerModel implements ICustomerModel {
    id: number;
    displayName: string | undefined;
    givenName: string | undefined;
    middleName: string | undefined;
    suffix: string | undefined;
    familyName: string | undefined;
    title: string | undefined;
    primaryEmailAddr: string | undefined;
    mobile: string | undefined;
    primaryPhone: string | undefined;
    fax: string | undefined;
    alternatePhone: string | undefined;
    companyName: string | undefined;
    sourceId: string | undefined;
    webSiteAddress: string | undefined;
    businessAddress: AddressDto;
    serviceAddress: AddressDto;

    constructor(data?: ICustomerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.givenName = _data["givenName"];
            this.middleName = _data["middleName"];
            this.suffix = _data["suffix"];
            this.familyName = _data["familyName"];
            this.title = _data["title"];
            this.primaryEmailAddr = _data["primaryEmailAddr"];
            this.mobile = _data["mobile"];
            this.primaryPhone = _data["primaryPhone"];
            this.fax = _data["fax"];
            this.alternatePhone = _data["alternatePhone"];
            this.companyName = _data["companyName"];
            this.sourceId = _data["sourceId"];
            this.webSiteAddress = _data["webSiteAddress"];
            this.businessAddress = _data["businessAddress"] ? AddressDto.fromJS(_data["businessAddress"]) : <any>undefined;
            this.serviceAddress = _data["serviceAddress"] ? AddressDto.fromJS(_data["serviceAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["givenName"] = this.givenName;
        data["middleName"] = this.middleName;
        data["suffix"] = this.suffix;
        data["familyName"] = this.familyName;
        data["title"] = this.title;
        data["primaryEmailAddr"] = this.primaryEmailAddr;
        data["mobile"] = this.mobile;
        data["primaryPhone"] = this.primaryPhone;
        data["fax"] = this.fax;
        data["alternatePhone"] = this.alternatePhone;
        data["companyName"] = this.companyName;
        data["sourceId"] = this.sourceId;
        data["webSiteAddress"] = this.webSiteAddress;
        data["businessAddress"] = this.businessAddress ? this.businessAddress.toJSON() : <any>undefined;
        data["serviceAddress"] = this.serviceAddress ? this.serviceAddress.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerModel {
        const json = this.toJSON();
        let result = new CustomerModel();
        result.init(json);
        return result;
    }
}

export interface ICustomerModel {
    id: number;
    displayName: string | undefined;
    givenName: string | undefined;
    middleName: string | undefined;
    suffix: string | undefined;
    familyName: string | undefined;
    title: string | undefined;
    primaryEmailAddr: string | undefined;
    mobile: string | undefined;
    primaryPhone: string | undefined;
    fax: string | undefined;
    alternatePhone: string | undefined;
    companyName: string | undefined;
    sourceId: string | undefined;
    webSiteAddress: string | undefined;
    businessAddress: AddressDto;
    serviceAddress: AddressDto;
}

export class CustomerModelGenericResponse implements ICustomerModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: CustomerModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: ICustomerModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? CustomerModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerModelGenericResponse {
        const json = this.toJSON();
        let result = new CustomerModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface ICustomerModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: CustomerModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class CustomerDetailModel implements ICustomerDetailModel {
    id: number;
    displayName: string | undefined;
    fullName: string | undefined;
    companyName: string | undefined;
    primaryEmailAddr: string | undefined;
    mobile: string | undefined;
    primaryPhone: string | undefined;
    businessAddress: string | undefined;
    givenName: string | undefined;
    title: string | undefined;
    middleName: string | undefined;
    suffix: string | undefined;
    familyName: string | undefined;
    fax: string | undefined;
    webSiteAddress: string | undefined;
    alternatePhone: string | undefined;
    sourceId: string | undefined;
    addresses: AddressDto[] | undefined;

    constructor(data?: ICustomerDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.fullName = _data["fullName"];
            this.companyName = _data["companyName"];
            this.primaryEmailAddr = _data["primaryEmailAddr"];
            this.mobile = _data["mobile"];
            this.primaryPhone = _data["primaryPhone"];
            this.businessAddress = _data["businessAddress"];
            this.givenName = _data["givenName"];
            this.title = _data["title"];
            this.middleName = _data["middleName"];
            this.suffix = _data["suffix"];
            this.familyName = _data["familyName"];
            this.fax = _data["fax"];
            this.webSiteAddress = _data["webSiteAddress"];
            this.alternatePhone = _data["alternatePhone"];
            this.sourceId = _data["sourceId"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses.push(AddressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["fullName"] = this.fullName;
        data["companyName"] = this.companyName;
        data["primaryEmailAddr"] = this.primaryEmailAddr;
        data["mobile"] = this.mobile;
        data["primaryPhone"] = this.primaryPhone;
        data["businessAddress"] = this.businessAddress;
        data["givenName"] = this.givenName;
        data["title"] = this.title;
        data["middleName"] = this.middleName;
        data["suffix"] = this.suffix;
        data["familyName"] = this.familyName;
        data["fax"] = this.fax;
        data["webSiteAddress"] = this.webSiteAddress;
        data["alternatePhone"] = this.alternatePhone;
        data["sourceId"] = this.sourceId;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CustomerDetailModel {
        const json = this.toJSON();
        let result = new CustomerDetailModel();
        result.init(json);
        return result;
    }
}

export interface ICustomerDetailModel {
    id: number;
    displayName: string | undefined;
    fullName: string | undefined;
    companyName: string | undefined;
    primaryEmailAddr: string | undefined;
    mobile: string | undefined;
    primaryPhone: string | undefined;
    businessAddress: string | undefined;
    givenName: string | undefined;
    title: string | undefined;
    middleName: string | undefined;
    suffix: string | undefined;
    familyName: string | undefined;
    fax: string | undefined;
    webSiteAddress: string | undefined;
    alternatePhone: string | undefined;
    sourceId: string | undefined;
    addresses: AddressDto[] | undefined;
}

export enum EntityTypes {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    __1 = -1,
}

export class DataImportResponseModel implements IDataImportResponseModel {
    companyId: number;
    totalImportedRecords: number;
    isSuccess: boolean | undefined;
    errors: string | undefined;
    entityType: EntityTypes;

    constructor(data?: IDataImportResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.totalImportedRecords = _data["totalImportedRecords"];
            this.isSuccess = _data["isSuccess"];
            this.errors = _data["errors"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): DataImportResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new DataImportResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["totalImportedRecords"] = this.totalImportedRecords;
        data["isSuccess"] = this.isSuccess;
        data["errors"] = this.errors;
        data["entityType"] = this.entityType;
        return data; 
    }

    clone(): DataImportResponseModel {
        const json = this.toJSON();
        let result = new DataImportResponseModel();
        result.init(json);
        return result;
    }
}

export interface IDataImportResponseModel {
    companyId: number;
    totalImportedRecords: number;
    isSuccess: boolean | undefined;
    errors: string | undefined;
    entityType: EntityTypes;
}

export class CustomerDto implements ICustomerDto {
    id: number;
    displayName: string | undefined;
    fullName: string | undefined;
    companyName: string | undefined;
    primaryEmailAddr: string | undefined;
    mobile: string | undefined;
    primaryPhone: string | undefined;
    businessAddress: string | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.fullName = _data["fullName"];
            this.companyName = _data["companyName"];
            this.primaryEmailAddr = _data["primaryEmailAddr"];
            this.mobile = _data["mobile"];
            this.primaryPhone = _data["primaryPhone"];
            this.businessAddress = _data["businessAddress"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["fullName"] = this.fullName;
        data["companyName"] = this.companyName;
        data["primaryEmailAddr"] = this.primaryEmailAddr;
        data["mobile"] = this.mobile;
        data["primaryPhone"] = this.primaryPhone;
        data["businessAddress"] = this.businessAddress;
        return data; 
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    id: number;
    displayName: string | undefined;
    fullName: string | undefined;
    companyName: string | undefined;
    primaryEmailAddr: string | undefined;
    mobile: string | undefined;
    primaryPhone: string | undefined;
    businessAddress: string | undefined;
}

export enum BatchActions {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class BatchActionRequestModel implements IBatchActionRequestModel {
    batchActionType: BatchActions;
    selectedIds: string[];
    entityType: EntityTypes;

    constructor(data?: IBatchActionRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.batchActionType = _data["batchActionType"];
            if (Array.isArray(_data["selectedIds"])) {
                this.selectedIds = [] as any;
                for (let item of _data["selectedIds"])
                    this.selectedIds.push(item);
            }
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): BatchActionRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new BatchActionRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batchActionType"] = this.batchActionType;
        if (Array.isArray(this.selectedIds)) {
            data["selectedIds"] = [];
            for (let item of this.selectedIds)
                data["selectedIds"].push(item);
        }
        data["entityType"] = this.entityType;
        return data; 
    }

    clone(): BatchActionRequestModel {
        const json = this.toJSON();
        let result = new BatchActionRequestModel();
        result.init(json);
        return result;
    }
}

export interface IBatchActionRequestModel {
    batchActionType: BatchActions;
    selectedIds: string[];
    entityType: EntityTypes;
}

export class BatchActionRequestModelGenericResponse implements IBatchActionRequestModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: BatchActionRequestModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IBatchActionRequestModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? BatchActionRequestModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BatchActionRequestModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BatchActionRequestModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BatchActionRequestModelGenericResponse {
        const json = this.toJSON();
        let result = new BatchActionRequestModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IBatchActionRequestModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: BatchActionRequestModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class CustomFieldDefinationModel implements ICustomFieldDefinationModel {
    companyId: number;
    userId: string | undefined;
    definationId: number;
    appliesToCustomTypeId: number;
    label: string | undefined;
    isRequired: boolean | undefined;
    isTransferable: boolean | undefined;
    defaultValue: string | undefined;
    fieldTypeId: number;
    displayOrder: number;

    constructor(data?: ICustomFieldDefinationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.userId = _data["userId"];
            this.definationId = _data["definationId"];
            this.appliesToCustomTypeId = _data["appliesToCustomTypeId"];
            this.label = _data["label"];
            this.isRequired = _data["isRequired"];
            this.isTransferable = _data["isTransferable"];
            this.defaultValue = _data["defaultValue"];
            this.fieldTypeId = _data["fieldTypeId"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CustomFieldDefinationModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldDefinationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["userId"] = this.userId;
        data["definationId"] = this.definationId;
        data["appliesToCustomTypeId"] = this.appliesToCustomTypeId;
        data["label"] = this.label;
        data["isRequired"] = this.isRequired;
        data["isTransferable"] = this.isTransferable;
        data["defaultValue"] = this.defaultValue;
        data["fieldTypeId"] = this.fieldTypeId;
        data["displayOrder"] = this.displayOrder;
        return data; 
    }

    clone(): CustomFieldDefinationModel {
        const json = this.toJSON();
        let result = new CustomFieldDefinationModel();
        result.init(json);
        return result;
    }
}

export interface ICustomFieldDefinationModel {
    companyId: number;
    userId: string | undefined;
    definationId: number;
    appliesToCustomTypeId: number;
    label: string | undefined;
    isRequired: boolean | undefined;
    isTransferable: boolean | undefined;
    defaultValue: string | undefined;
    fieldTypeId: number;
    displayOrder: number;
}

export class CustomFieldDefinationModelGenericResponse implements ICustomFieldDefinationModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: CustomFieldDefinationModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: ICustomFieldDefinationModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? CustomFieldDefinationModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomFieldDefinationModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldDefinationModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomFieldDefinationModelGenericResponse {
        const json = this.toJSON();
        let result = new CustomFieldDefinationModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface ICustomFieldDefinationModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: CustomFieldDefinationModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class CustomFieldEntityType implements ICustomFieldEntityType {
    entityId: number;
    entityName: string | undefined;
    maxFieldsAllowed: number;
    entityType: number;

    constructor(data?: ICustomFieldEntityType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityName = _data["entityName"];
            this.maxFieldsAllowed = _data["maxFieldsAllowed"];
            this.entityType = _data["entityType"];
        }
    }

    static fromJS(data: any): CustomFieldEntityType {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldEntityType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityName"] = this.entityName;
        data["maxFieldsAllowed"] = this.maxFieldsAllowed;
        data["entityType"] = this.entityType;
        return data; 
    }

    clone(): CustomFieldEntityType {
        const json = this.toJSON();
        let result = new CustomFieldEntityType();
        result.init(json);
        return result;
    }
}

export interface ICustomFieldEntityType {
    entityId: number;
    entityName: string | undefined;
    maxFieldsAllowed: number;
    entityType: number;
}

export class CustomFieldType implements ICustomFieldType {
    customTypeFieldId: number;
    fieldName: string | undefined;
    fieldType: number;
    canBeTransferable: boolean | undefined;

    constructor(data?: ICustomFieldType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTypeFieldId = _data["customTypeFieldId"];
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.canBeTransferable = _data["canBeTransferable"];
        }
    }

    static fromJS(data: any): CustomFieldType {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTypeFieldId"] = this.customTypeFieldId;
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["canBeTransferable"] = this.canBeTransferable;
        return data; 
    }

    clone(): CustomFieldType {
        const json = this.toJSON();
        let result = new CustomFieldType();
        result.init(json);
        return result;
    }
}

export interface ICustomFieldType {
    customTypeFieldId: number;
    fieldName: string | undefined;
    fieldType: number;
    canBeTransferable: boolean | undefined;
}

export class CustomFieldTypesResult implements ICustomFieldTypesResult {
    customFieldEntityTypes: CustomFieldEntityType[] | undefined;
    customFieldTypes: CustomFieldType[] | undefined;

    constructor(data?: ICustomFieldTypesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customFieldEntityTypes"])) {
                this.customFieldEntityTypes = [] as any;
                for (let item of _data["customFieldEntityTypes"])
                    this.customFieldEntityTypes.push(CustomFieldEntityType.fromJS(item));
            }
            if (Array.isArray(_data["customFieldTypes"])) {
                this.customFieldTypes = [] as any;
                for (let item of _data["customFieldTypes"])
                    this.customFieldTypes.push(CustomFieldType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomFieldTypesResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldTypesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customFieldEntityTypes)) {
            data["customFieldEntityTypes"] = [];
            for (let item of this.customFieldEntityTypes)
                data["customFieldEntityTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.customFieldTypes)) {
            data["customFieldTypes"] = [];
            for (let item of this.customFieldTypes)
                data["customFieldTypes"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CustomFieldTypesResult {
        const json = this.toJSON();
        let result = new CustomFieldTypesResult();
        result.init(json);
        return result;
    }
}

export interface ICustomFieldTypesResult {
    customFieldEntityTypes: CustomFieldEntityType[] | undefined;
    customFieldTypes: CustomFieldType[] | undefined;
}

export class ExpenseCodeModel implements IExpenseCodeModel {
    expenseCodeId: number;
    codeName: string | undefined;

    constructor(data?: IExpenseCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseCodeId = _data["expenseCodeId"];
            this.codeName = _data["codeName"];
        }
    }

    static fromJS(data: any): ExpenseCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseCodeId"] = this.expenseCodeId;
        data["codeName"] = this.codeName;
        return data; 
    }

    clone(): ExpenseCodeModel {
        const json = this.toJSON();
        let result = new ExpenseCodeModel();
        result.init(json);
        return result;
    }
}

export interface IExpenseCodeModel {
    expenseCodeId: number;
    codeName: string | undefined;
}

export class ExpenseCodeModelGenericResponse implements IExpenseCodeModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: ExpenseCodeModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IExpenseCodeModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? ExpenseCodeModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpenseCodeModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseCodeModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ExpenseCodeModelGenericResponse {
        const json = this.toJSON();
        let result = new ExpenseCodeModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IExpenseCodeModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: ExpenseCodeModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export enum EmployeeTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum EmployeeStatuses {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TeamDto implements ITeamDto {
    teamId: number;
    teamName: string | undefined;
    description: string | undefined;
    employees: EmployeeDto[] | undefined;

    constructor(data?: ITeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.teamId = _data["teamId"];
            this.teamName = _data["teamName"];
            this.description = _data["description"];
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees.push(EmployeeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["teamId"] = this.teamId;
        data["teamName"] = this.teamName;
        data["description"] = this.description;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TeamDto {
        const json = this.toJSON();
        let result = new TeamDto();
        result.init(json);
        return result;
    }
}

export interface ITeamDto {
    teamId: number;
    teamName: string | undefined;
    description: string | undefined;
    employees: EmployeeDto[] | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    title: string | undefined;
    givenName: string | undefined;
    displayName: string | undefined;
    email: string | undefined;
    employeeType: EmployeeTypes;
    status: EmployeeStatuses;
    employeeId: number;
    team: TeamDto;
    readonly fullDisplayName: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.givenName = _data["givenName"];
            this.displayName = _data["displayName"];
            this.email = _data["email"];
            this.employeeType = _data["employeeType"];
            this.status = _data["status"];
            this.employeeId = _data["employeeId"];
            this.team = _data["team"] ? TeamDto.fromJS(_data["team"]) : <any>undefined;
            (<any>this).fullDisplayName = _data["fullDisplayName"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["givenName"] = this.givenName;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["employeeType"] = this.employeeType;
        data["status"] = this.status;
        data["employeeId"] = this.employeeId;
        data["team"] = this.team ? this.team.toJSON() : <any>undefined;
        data["fullDisplayName"] = this.fullDisplayName;
        return data; 
    }

    clone(): EmployeeDto {
        const json = this.toJSON();
        let result = new EmployeeDto();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDto {
    title: string | undefined;
    givenName: string | undefined;
    displayName: string | undefined;
    email: string | undefined;
    employeeType: EmployeeTypes;
    status: EmployeeStatuses;
    employeeId: number;
    team: TeamDto;
    fullDisplayName: string | undefined;
}

export class CreateExpenseModel implements ICreateExpenseModel {
    companyId: number;
    userId: string | undefined;
    expenseId: number;
    expenseDate: moment.Moment;
    title: string | undefined;
    description: string | undefined;
    amount: number;
    reimburseToEmployeeId: EmployeeDto;
    jobId: number | undefined;
    expenseCode: ExpenseCodeModel;

    constructor(data?: ICreateExpenseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.userId = _data["userId"];
            this.expenseId = _data["expenseId"];
            this.expenseDate = _data["expenseDate"] ? moment(_data["expenseDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.reimburseToEmployeeId = _data["reimburseToEmployeeId"] ? EmployeeDto.fromJS(_data["reimburseToEmployeeId"]) : <any>undefined;
            this.jobId = _data["jobId"];
            this.expenseCode = _data["expenseCode"] ? ExpenseCodeModel.fromJS(_data["expenseCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateExpenseModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExpenseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["userId"] = this.userId;
        data["expenseId"] = this.expenseId;
        data["expenseDate"] = this.expenseDate ? this.expenseDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["reimburseToEmployeeId"] = this.reimburseToEmployeeId ? this.reimburseToEmployeeId.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["expenseCode"] = this.expenseCode ? this.expenseCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateExpenseModel {
        const json = this.toJSON();
        let result = new CreateExpenseModel();
        result.init(json);
        return result;
    }
}

export interface ICreateExpenseModel {
    companyId: number;
    userId: string | undefined;
    expenseId: number;
    expenseDate: moment.Moment;
    title: string | undefined;
    description: string | undefined;
    amount: number;
    reimburseToEmployeeId: EmployeeDto;
    jobId: number | undefined;
    expenseCode: ExpenseCodeModel;
}

export class ExpenseDto implements IExpenseDto {
    expenseId: number;
    title: string | undefined;
    description: string | undefined;
    amount: number;
    expenseDate: moment.Moment;
    jobId: number | undefined;
    createdByName: string | undefined;
    reimburseDisplayName: string | undefined;
    reimburseToEmployeeId: number;
    isApproved: boolean;
    approvedBy: string | undefined;
    expenseCodeName: string | undefined;

    constructor(data?: IExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expenseId = _data["expenseId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.expenseDate = _data["expenseDate"] ? moment(_data["expenseDate"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.createdByName = _data["createdByName"];
            this.reimburseDisplayName = _data["reimburseDisplayName"];
            this.reimburseToEmployeeId = _data["reimburseToEmployeeId"];
            this.isApproved = _data["isApproved"];
            this.approvedBy = _data["approvedBy"];
            this.expenseCodeName = _data["expenseCodeName"];
        }
    }

    static fromJS(data: any): ExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expenseId"] = this.expenseId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["expenseDate"] = this.expenseDate ? this.expenseDate.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["createdByName"] = this.createdByName;
        data["reimburseDisplayName"] = this.reimburseDisplayName;
        data["reimburseToEmployeeId"] = this.reimburseToEmployeeId;
        data["isApproved"] = this.isApproved;
        data["approvedBy"] = this.approvedBy;
        data["expenseCodeName"] = this.expenseCodeName;
        return data; 
    }

    clone(): ExpenseDto {
        const json = this.toJSON();
        let result = new ExpenseDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseDto {
    expenseId: number;
    title: string | undefined;
    description: string | undefined;
    amount: number;
    expenseDate: moment.Moment;
    jobId: number | undefined;
    createdByName: string | undefined;
    reimburseDisplayName: string | undefined;
    reimburseToEmployeeId: number;
    isApproved: boolean;
    approvedBy: string | undefined;
    expenseCodeName: string | undefined;
}

export class ExpenseDtoGenericResponse implements IExpenseDtoGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: ExpenseDto;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IExpenseDtoGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? ExpenseDto.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExpenseDtoGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDtoGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ExpenseDtoGenericResponse {
        const json = this.toJSON();
        let result = new ExpenseDtoGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IExpenseDtoGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: ExpenseDto;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class JobFormDefinationDto implements IJobFormDefinationDto {
    formId: number;
    formName: string | undefined;
    description: string | undefined;
    autoAddToNewJobs: boolean | undefined;
    entityStatus: EntityStatuses;
    allowMultipleVersions: boolean;

    constructor(data?: IJobFormDefinationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formName = _data["formName"];
            this.description = _data["description"];
            this.autoAddToNewJobs = _data["autoAddToNewJobs"];
            this.entityStatus = _data["entityStatus"];
            this.allowMultipleVersions = _data["allowMultipleVersions"];
        }
    }

    static fromJS(data: any): JobFormDefinationDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobFormDefinationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formName"] = this.formName;
        data["description"] = this.description;
        data["autoAddToNewJobs"] = this.autoAddToNewJobs;
        data["entityStatus"] = this.entityStatus;
        data["allowMultipleVersions"] = this.allowMultipleVersions;
        return data; 
    }

    clone(): JobFormDefinationDto {
        const json = this.toJSON();
        let result = new JobFormDefinationDto();
        result.init(json);
        return result;
    }
}

export interface IJobFormDefinationDto {
    formId: number;
    formName: string | undefined;
    description: string | undefined;
    autoAddToNewJobs: boolean | undefined;
    entityStatus: EntityStatuses;
    allowMultipleVersions: boolean;
}

export enum FieldTypes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export class Field implements IField {
    fieldId: number;
    fieldType: FieldTypes;
    fieldTypeName: string | undefined;
    fieldQuestion: string | undefined;
    fieldAnswer: string | undefined;
    isRequired: boolean | undefined;
    valueSource: string | undefined;
    displayOrder: number;
    sectionId: number;
    defaultValues: any | undefined;

    constructor(data?: IField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.fieldType = _data["fieldType"];
            this.fieldTypeName = _data["fieldTypeName"];
            this.fieldQuestion = _data["fieldQuestion"];
            this.fieldAnswer = _data["fieldAnswer"];
            this.isRequired = _data["isRequired"];
            this.valueSource = _data["valueSource"];
            this.displayOrder = _data["displayOrder"];
            this.sectionId = _data["sectionId"];
            this.defaultValues = _data["defaultValues"];
        }
    }

    static fromJS(data: any): Field {
        data = typeof data === 'object' ? data : {};
        let result = new Field();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["fieldType"] = this.fieldType;
        data["fieldTypeName"] = this.fieldTypeName;
        data["fieldQuestion"] = this.fieldQuestion;
        data["fieldAnswer"] = this.fieldAnswer;
        data["isRequired"] = this.isRequired;
        data["valueSource"] = this.valueSource;
        data["displayOrder"] = this.displayOrder;
        data["sectionId"] = this.sectionId;
        data["defaultValues"] = this.defaultValues;
        return data; 
    }

    clone(): Field {
        const json = this.toJSON();
        let result = new Field();
        result.init(json);
        return result;
    }
}

export interface IField {
    fieldId: number;
    fieldType: FieldTypes;
    fieldTypeName: string | undefined;
    fieldQuestion: string | undefined;
    fieldAnswer: string | undefined;
    isRequired: boolean | undefined;
    valueSource: string | undefined;
    displayOrder: number;
    sectionId: number;
    defaultValues: any | undefined;
}

export class Section implements ISection {
    formSectionId: number;
    displayOrder: number;
    sectionName: string | undefined;
    fields: Field[] | undefined;

    constructor(data?: ISection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formSectionId = _data["formSectionId"];
            this.displayOrder = _data["displayOrder"];
            this.sectionName = _data["sectionName"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields.push(Field.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Section {
        data = typeof data === 'object' ? data : {};
        let result = new Section();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formSectionId"] = this.formSectionId;
        data["displayOrder"] = this.displayOrder;
        data["sectionName"] = this.sectionName;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Section {
        const json = this.toJSON();
        let result = new Section();
        result.init(json);
        return result;
    }
}

export interface ISection {
    formSectionId: number;
    displayOrder: number;
    sectionName: string | undefined;
    fields: Field[] | undefined;
}

export class JobFormModel implements IJobFormModel {
    formId: number;
    formName: string | undefined;
    description: string | undefined;
    autoAddToNewJobs: boolean;
    allowMultipleVersions: boolean;
    sections: Section[] | undefined;

    constructor(data?: IJobFormModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formName = _data["formName"];
            this.description = _data["description"];
            this.autoAddToNewJobs = _data["autoAddToNewJobs"];
            this.allowMultipleVersions = _data["allowMultipleVersions"];
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections.push(Section.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobFormModel {
        data = typeof data === 'object' ? data : {};
        let result = new JobFormModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formName"] = this.formName;
        data["description"] = this.description;
        data["autoAddToNewJobs"] = this.autoAddToNewJobs;
        data["allowMultipleVersions"] = this.allowMultipleVersions;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data; 
    }

    clone(): JobFormModel {
        const json = this.toJSON();
        let result = new JobFormModel();
        result.init(json);
        return result;
    }
}

export interface IJobFormModel {
    formId: number;
    formName: string | undefined;
    description: string | undefined;
    autoAddToNewJobs: boolean;
    allowMultipleVersions: boolean;
    sections: Section[] | undefined;
}

export class JobFormModelGenericResponse implements IJobFormModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: JobFormModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IJobFormModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? JobFormModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobFormModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JobFormModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): JobFormModelGenericResponse {
        const json = this.toJSON();
        let result = new JobFormModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IJobFormModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: JobFormModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class JobFormDataModel implements IJobFormDataModel {
    fieldId: number;
    fieldType: FieldTypes;
    fieldData: string | undefined;
    dataId: number;
    formSectionId: number;

    constructor(data?: IJobFormDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.fieldType = _data["fieldType"];
            this.fieldData = _data["fieldData"];
            this.dataId = _data["dataId"];
            this.formSectionId = _data["formSectionId"];
        }
    }

    static fromJS(data: any): JobFormDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new JobFormDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["fieldType"] = this.fieldType;
        data["fieldData"] = this.fieldData;
        data["dataId"] = this.dataId;
        data["formSectionId"] = this.formSectionId;
        return data; 
    }

    clone(): JobFormDataModel {
        const json = this.toJSON();
        let result = new JobFormDataModel();
        result.init(json);
        return result;
    }
}

export interface IJobFormDataModel {
    fieldId: number;
    fieldType: FieldTypes;
    fieldData: string | undefined;
    dataId: number;
    formSectionId: number;
}

export class JobFormDataDetailSingle implements IJobFormDataDetailSingle {
    formModel: JobFormModel;
    fieldsData: JobFormDataModel[] | undefined;

    constructor(data?: IJobFormDataDetailSingle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formModel = _data["formModel"] ? JobFormModel.fromJS(_data["formModel"]) : <any>undefined;
            if (Array.isArray(_data["fieldsData"])) {
                this.fieldsData = [] as any;
                for (let item of _data["fieldsData"])
                    this.fieldsData.push(JobFormDataModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobFormDataDetailSingle {
        data = typeof data === 'object' ? data : {};
        let result = new JobFormDataDetailSingle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formModel"] = this.formModel ? this.formModel.toJSON() : <any>undefined;
        if (Array.isArray(this.fieldsData)) {
            data["fieldsData"] = [];
            for (let item of this.fieldsData)
                data["fieldsData"].push(item.toJSON());
        }
        return data; 
    }

    clone(): JobFormDataDetailSingle {
        const json = this.toJSON();
        let result = new JobFormDataDetailSingle();
        result.init(json);
        return result;
    }
}

export interface IJobFormDataDetailSingle {
    formModel: JobFormModel;
    fieldsData: JobFormDataModel[] | undefined;
}

export class JobFormDataDetailSingleGenericResponse implements IJobFormDataDetailSingleGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: JobFormDataDetailSingle;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IJobFormDataDetailSingleGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? JobFormDataDetailSingle.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobFormDataDetailSingleGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JobFormDataDetailSingleGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): JobFormDataDetailSingleGenericResponse {
        const json = this.toJSON();
        let result = new JobFormDataDetailSingleGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IJobFormDataDetailSingleGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: JobFormDataDetailSingle;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class ProductDto implements IProductDto {
    productId: number;
    name: string | undefined;
    description: string | undefined;
    type: string | undefined;
    itemCategoryType: string | undefined;
    taxable: boolean | undefined;
    unitPrice: number | undefined;
    quantity: number | undefined;
    sku: string | undefined;
    readonly isServiceType: boolean;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.itemCategoryType = _data["itemCategoryType"];
            this.taxable = _data["taxable"];
            this.unitPrice = _data["unitPrice"];
            this.quantity = _data["quantity"];
            this.sku = _data["sku"];
            (<any>this).isServiceType = _data["isServiceType"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["itemCategoryType"] = this.itemCategoryType;
        data["taxable"] = this.taxable;
        data["unitPrice"] = this.unitPrice;
        data["quantity"] = this.quantity;
        data["sku"] = this.sku;
        data["isServiceType"] = this.isServiceType;
        return data; 
    }

    clone(): ProductDto {
        const json = this.toJSON();
        let result = new ProductDto();
        result.init(json);
        return result;
    }
}

export interface IProductDto {
    productId: number;
    name: string | undefined;
    description: string | undefined;
    type: string | undefined;
    itemCategoryType: string | undefined;
    taxable: boolean | undefined;
    unitPrice: number | undefined;
    quantity: number | undefined;
    sku: string | undefined;
    isServiceType: boolean;
}

export class UserDto implements IUserDto {
    firstName: string | undefined;
    displayName: string | undefined;
    lastName: string | undefined;
    employeeNumber: string | undefined;
    userId: string | undefined;
    employeeId: number;
    email: string | undefined;
    primaryPhone: string | undefined;
    userColor: string | undefined;
    mobile: string | undefined;
    isAdministrator: string | undefined;
    roleName: string | undefined;
    billRate: number;
    readonly fullName: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.displayName = _data["displayName"];
            this.lastName = _data["lastName"];
            this.employeeNumber = _data["employeeNumber"];
            this.userId = _data["userId"];
            this.employeeId = _data["employeeId"];
            this.email = _data["email"];
            this.primaryPhone = _data["primaryPhone"];
            this.userColor = _data["userColor"];
            this.mobile = _data["mobile"];
            this.isAdministrator = _data["isAdministrator"];
            this.roleName = _data["roleName"];
            this.billRate = _data["billRate"];
            (<any>this).fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["displayName"] = this.displayName;
        data["lastName"] = this.lastName;
        data["employeeNumber"] = this.employeeNumber;
        data["userId"] = this.userId;
        data["employeeId"] = this.employeeId;
        data["email"] = this.email;
        data["primaryPhone"] = this.primaryPhone;
        data["userColor"] = this.userColor;
        data["mobile"] = this.mobile;
        data["isAdministrator"] = this.isAdministrator;
        data["roleName"] = this.roleName;
        data["billRate"] = this.billRate;
        data["fullName"] = this.fullName;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    firstName: string | undefined;
    displayName: string | undefined;
    lastName: string | undefined;
    employeeNumber: string | undefined;
    userId: string | undefined;
    employeeId: number;
    email: string | undefined;
    primaryPhone: string | undefined;
    userColor: string | undefined;
    mobile: string | undefined;
    isAdministrator: string | undefined;
    roleName: string | undefined;
    billRate: number;
    fullName: string | undefined;
}

export class CreateJobModel implements ICreateJobModel {
    customer: CustomerDto;
    jobAddress: AddressDto;
    jobTitle: string | undefined;
    serviceType: ProductDto;
    jobNumber: string | undefined;
    readonly jobNumberDefined: boolean;
    jobDescription: string | undefined;
    internalNotes: string | undefined;
    assignedTo: UserDto;
    startDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    scheduleLater: boolean;
    jobColor: string | undefined;
    projectId: number | undefined;
    parentJobId: number | undefined;
    jobId: number;
    contactEmail: string | undefined;
    contactPhone: string | undefined;

    constructor(data?: ICreateJobModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customer = _data["customer"] ? CustomerDto.fromJS(_data["customer"]) : <any>undefined;
            this.jobAddress = _data["jobAddress"] ? AddressDto.fromJS(_data["jobAddress"]) : <any>undefined;
            this.jobTitle = _data["jobTitle"];
            this.serviceType = _data["serviceType"] ? ProductDto.fromJS(_data["serviceType"]) : <any>undefined;
            this.jobNumber = _data["jobNumber"];
            (<any>this).jobNumberDefined = _data["jobNumberDefined"];
            this.jobDescription = _data["jobDescription"];
            this.internalNotes = _data["internalNotes"];
            this.assignedTo = _data["assignedTo"] ? UserDto.fromJS(_data["assignedTo"]) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.scheduleLater = _data["scheduleLater"];
            this.jobColor = _data["jobColor"];
            this.projectId = _data["projectId"];
            this.parentJobId = _data["parentJobId"];
            this.jobId = _data["jobId"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
        }
    }

    static fromJS(data: any): CreateJobModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["jobAddress"] = this.jobAddress ? this.jobAddress.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        data["serviceType"] = this.serviceType ? this.serviceType.toJSON() : <any>undefined;
        data["jobNumber"] = this.jobNumber;
        data["jobNumberDefined"] = this.jobNumberDefined;
        data["jobDescription"] = this.jobDescription;
        data["internalNotes"] = this.internalNotes;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["scheduleLater"] = this.scheduleLater;
        data["jobColor"] = this.jobColor;
        data["projectId"] = this.projectId;
        data["parentJobId"] = this.parentJobId;
        data["jobId"] = this.jobId;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        return data; 
    }

    clone(): CreateJobModel {
        const json = this.toJSON();
        let result = new CreateJobModel();
        result.init(json);
        return result;
    }
}

export interface ICreateJobModel {
    customer: CustomerDto;
    jobAddress: AddressDto;
    jobTitle: string | undefined;
    serviceType: ProductDto;
    jobNumber: string | undefined;
    jobNumberDefined: boolean;
    jobDescription: string | undefined;
    internalNotes: string | undefined;
    assignedTo: UserDto;
    startDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    scheduleLater: boolean;
    jobColor: string | undefined;
    projectId: number | undefined;
    parentJobId: number | undefined;
    jobId: number;
    contactEmail: string | undefined;
    contactPhone: string | undefined;
}

export class CreateJobModelGenericResponse implements ICreateJobModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: CreateJobModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: ICreateJobModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? CreateJobModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateJobModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateJobModelGenericResponse {
        const json = this.toJSON();
        let result = new CreateJobModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateJobModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: CreateJobModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class JobLineItemDto implements IJobLineItemDto {
    itemId: number;
    productId: number;
    product: ProductDto;
    taxable: boolean;
    quantity: number;
    price: number;
    markup: number | undefined;
    displayOrder: number | undefined;
    discountValue: number | undefined;
    discountType: number | undefined;
    description: string | undefined;
    visitId: number;
    jobId: number;

    constructor(data?: IJobLineItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.taxable = _data["taxable"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.markup = _data["markup"];
            this.displayOrder = _data["displayOrder"];
            this.discountValue = _data["discountValue"];
            this.discountType = _data["discountType"];
            this.description = _data["description"];
            this.visitId = _data["visitId"];
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): JobLineItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobLineItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["taxable"] = this.taxable;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["markup"] = this.markup;
        data["displayOrder"] = this.displayOrder;
        data["discountValue"] = this.discountValue;
        data["discountType"] = this.discountType;
        data["description"] = this.description;
        data["visitId"] = this.visitId;
        data["jobId"] = this.jobId;
        return data; 
    }

    clone(): JobLineItemDto {
        const json = this.toJSON();
        let result = new JobLineItemDto();
        result.init(json);
        return result;
    }
}

export interface IJobLineItemDto {
    itemId: number;
    productId: number;
    product: ProductDto;
    taxable: boolean;
    quantity: number;
    price: number;
    markup: number | undefined;
    displayOrder: number | undefined;
    discountValue: number | undefined;
    discountType: number | undefined;
    description: string | undefined;
    visitId: number;
    jobId: number;
}

export class CreateJobVisitModel implements ICreateJobVisitModel {
    title: string | undefined;
    description: string | undefined;
    jobId: number;
    startDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    assignedTo: EmployeeDto;
    endDate: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    scheduleLater: boolean;
    visitItems: JobLineItemDto[] | undefined;
    notifyCustomer: boolean | undefined;

    constructor(data?: ICreateJobVisitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.jobId = _data["jobId"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.assignedTo = _data["assignedTo"] ? EmployeeDto.fromJS(_data["assignedTo"]) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.scheduleLater = _data["scheduleLater"];
            if (Array.isArray(_data["visitItems"])) {
                this.visitItems = [] as any;
                for (let item of _data["visitItems"])
                    this.visitItems.push(JobLineItemDto.fromJS(item));
            }
            this.notifyCustomer = _data["notifyCustomer"];
        }
    }

    static fromJS(data: any): CreateJobVisitModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobVisitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["jobId"] = this.jobId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["scheduleLater"] = this.scheduleLater;
        if (Array.isArray(this.visitItems)) {
            data["visitItems"] = [];
            for (let item of this.visitItems)
                data["visitItems"].push(item.toJSON());
        }
        data["notifyCustomer"] = this.notifyCustomer;
        return data; 
    }

    clone(): CreateJobVisitModel {
        const json = this.toJSON();
        let result = new CreateJobVisitModel();
        result.init(json);
        return result;
    }
}

export interface ICreateJobVisitModel {
    title: string | undefined;
    description: string | undefined;
    jobId: number;
    startDate: moment.Moment | undefined;
    startTime: moment.Moment | undefined;
    assignedTo: EmployeeDto;
    endDate: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    scheduleLater: boolean;
    visitItems: JobLineItemDto[] | undefined;
    notifyCustomer: boolean | undefined;
}

export enum VisitStatuses {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class JobVisitDto implements IJobVisitDto {
    visitId: number;
    title: string | undefined;
    description: string | undefined;
    isBillable: boolean;
    visitStatus: VisitStatuses;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    actualStartDateTime: moment.Moment | undefined;
    actualEndDateTime: moment.Moment | undefined;
    assignedTo: EmployeeDto;
    readonly visitStatusValue: string | undefined;
    readonly isAssigned: boolean;
    hasSameDate: boolean;
    scheduleLater: boolean | undefined;
    sequence: number;
    readonly fullTitle: string | undefined;
    lineItems: JobLineItemDto[] | undefined;
    isChecked: boolean;
    readonly isCompleted: boolean;

    constructor(data?: IJobVisitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visitId = _data["visitId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isBillable = _data["isBillable"];
            this.visitStatus = _data["visitStatus"];
            this.startDateTime = _data["startDateTime"] ? moment(_data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = _data["endDateTime"] ? moment(_data["endDateTime"].toString()) : <any>undefined;
            this.actualStartDateTime = _data["actualStartDateTime"] ? moment(_data["actualStartDateTime"].toString()) : <any>undefined;
            this.actualEndDateTime = _data["actualEndDateTime"] ? moment(_data["actualEndDateTime"].toString()) : <any>undefined;
            this.assignedTo = _data["assignedTo"] ? EmployeeDto.fromJS(_data["assignedTo"]) : <any>undefined;
            (<any>this).visitStatusValue = _data["visitStatusValue"];
            (<any>this).isAssigned = _data["isAssigned"];
            this.hasSameDate = _data["hasSameDate"];
            this.scheduleLater = _data["scheduleLater"];
            this.sequence = _data["sequence"];
            (<any>this).fullTitle = _data["fullTitle"];
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems.push(JobLineItemDto.fromJS(item));
            }
            this.isChecked = _data["isChecked"];
            (<any>this).isCompleted = _data["isCompleted"];
        }
    }

    static fromJS(data: any): JobVisitDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobVisitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitId"] = this.visitId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isBillable"] = this.isBillable;
        data["visitStatus"] = this.visitStatus;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["actualStartDateTime"] = this.actualStartDateTime ? this.actualStartDateTime.toISOString() : <any>undefined;
        data["actualEndDateTime"] = this.actualEndDateTime ? this.actualEndDateTime.toISOString() : <any>undefined;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["visitStatusValue"] = this.visitStatusValue;
        data["isAssigned"] = this.isAssigned;
        data["hasSameDate"] = this.hasSameDate;
        data["scheduleLater"] = this.scheduleLater;
        data["sequence"] = this.sequence;
        data["fullTitle"] = this.fullTitle;
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        data["isChecked"] = this.isChecked;
        data["isCompleted"] = this.isCompleted;
        return data; 
    }

    clone(): JobVisitDto {
        const json = this.toJSON();
        let result = new JobVisitDto();
        result.init(json);
        return result;
    }
}

export interface IJobVisitDto {
    visitId: number;
    title: string | undefined;
    description: string | undefined;
    isBillable: boolean;
    visitStatus: VisitStatuses;
    startDateTime: moment.Moment | undefined;
    endDateTime: moment.Moment | undefined;
    actualStartDateTime: moment.Moment | undefined;
    actualEndDateTime: moment.Moment | undefined;
    assignedTo: EmployeeDto;
    visitStatusValue: string | undefined;
    isAssigned: boolean;
    hasSameDate: boolean;
    scheduleLater: boolean | undefined;
    sequence: number;
    fullTitle: string | undefined;
    lineItems: JobLineItemDto[] | undefined;
    isChecked: boolean;
    isCompleted: boolean;
}

export class JobVisitDtoGenericResponse implements IJobVisitDtoGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: JobVisitDto;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IJobVisitDtoGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? JobVisitDto.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobVisitDtoGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JobVisitDtoGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): JobVisitDtoGenericResponse {
        const json = this.toJSON();
        let result = new JobVisitDtoGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IJobVisitDtoGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: JobVisitDto;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export enum JobStatuses {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    __1 = -1,
}

export class JobFilterModel implements IJobFilterModel {
    status: JobStatuses;

    constructor(data?: IJobFilterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): JobFilterModel {
        data = typeof data === 'object' ? data : {};
        let result = new JobFilterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data; 
    }

    clone(): JobFilterModel {
        const json = this.toJSON();
        let result = new JobFilterModel();
        result.init(json);
        return result;
    }
}

export interface IJobFilterModel {
    status: JobStatuses;
}

export class JobDto implements IJobDto {
    customer: CustomerDto;
    jobAddress: AddressDto;
    title: string | undefined;
    serviceType: ProductDto;
    prefix: string | undefined;
    jobNumber: string | undefined;
    readonly fullJobNumber: string | undefined;
    readonly heading: string | undefined;
    readonly jobNumberDefined: boolean;
    description: string | undefined;
    internalNotes: string | undefined;
    assignedTo: EmployeeDto;
    readonly isUnassigned: boolean;
    scheduleLater: boolean;
    jobColor: string | undefined;
    jobId: number;
    createdBy: UserDto;
    jobStatus: JobStatuses;
    contactEmail: string | undefined;
    contactPhone: string | undefined;
    readonly jobStatusText: string | undefined;

    constructor(data?: IJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customer = _data["customer"] ? CustomerDto.fromJS(_data["customer"]) : <any>undefined;
            this.jobAddress = _data["jobAddress"] ? AddressDto.fromJS(_data["jobAddress"]) : <any>undefined;
            this.title = _data["title"];
            this.serviceType = _data["serviceType"] ? ProductDto.fromJS(_data["serviceType"]) : <any>undefined;
            this.prefix = _data["prefix"];
            this.jobNumber = _data["jobNumber"];
            (<any>this).fullJobNumber = _data["fullJobNumber"];
            (<any>this).heading = _data["heading"];
            (<any>this).jobNumberDefined = _data["jobNumberDefined"];
            this.description = _data["description"];
            this.internalNotes = _data["internalNotes"];
            this.assignedTo = _data["assignedTo"] ? EmployeeDto.fromJS(_data["assignedTo"]) : <any>undefined;
            (<any>this).isUnassigned = _data["isUnassigned"];
            this.scheduleLater = _data["scheduleLater"];
            this.jobColor = _data["jobColor"];
            this.jobId = _data["jobId"];
            this.createdBy = _data["createdBy"] ? UserDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.jobStatus = _data["jobStatus"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            (<any>this).jobStatusText = _data["jobStatusText"];
        }
    }

    static fromJS(data: any): JobDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["jobAddress"] = this.jobAddress ? this.jobAddress.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["serviceType"] = this.serviceType ? this.serviceType.toJSON() : <any>undefined;
        data["prefix"] = this.prefix;
        data["jobNumber"] = this.jobNumber;
        data["fullJobNumber"] = this.fullJobNumber;
        data["heading"] = this.heading;
        data["jobNumberDefined"] = this.jobNumberDefined;
        data["description"] = this.description;
        data["internalNotes"] = this.internalNotes;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["isUnassigned"] = this.isUnassigned;
        data["scheduleLater"] = this.scheduleLater;
        data["jobColor"] = this.jobColor;
        data["jobId"] = this.jobId;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["jobStatus"] = this.jobStatus;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["jobStatusText"] = this.jobStatusText;
        return data; 
    }

    clone(): JobDto {
        const json = this.toJSON();
        let result = new JobDto();
        result.init(json);
        return result;
    }
}

export interface IJobDto {
    customer: CustomerDto;
    jobAddress: AddressDto;
    title: string | undefined;
    serviceType: ProductDto;
    prefix: string | undefined;
    jobNumber: string | undefined;
    fullJobNumber: string | undefined;
    heading: string | undefined;
    jobNumberDefined: boolean;
    description: string | undefined;
    internalNotes: string | undefined;
    assignedTo: EmployeeDto;
    isUnassigned: boolean;
    scheduleLater: boolean;
    jobColor: string | undefined;
    jobId: number;
    createdBy: UserDto;
    jobStatus: JobStatuses;
    contactEmail: string | undefined;
    contactPhone: string | undefined;
    jobStatusText: string | undefined;
}

export class JobFormDto implements IJobFormDto {
    formId: number;
    formName: string | undefined;
    hasMultipleVersions: boolean | undefined;
    allowMultipleVersions: boolean | undefined;

    constructor(data?: IJobFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formId = _data["formId"];
            this.formName = _data["formName"];
            this.hasMultipleVersions = _data["hasMultipleVersions"];
            this.allowMultipleVersions = _data["allowMultipleVersions"];
        }
    }

    static fromJS(data: any): JobFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formId"] = this.formId;
        data["formName"] = this.formName;
        data["hasMultipleVersions"] = this.hasMultipleVersions;
        data["allowMultipleVersions"] = this.allowMultipleVersions;
        return data; 
    }

    clone(): JobFormDto {
        const json = this.toJSON();
        let result = new JobFormDto();
        result.init(json);
        return result;
    }
}

export interface IJobFormDto {
    formId: number;
    formName: string | undefined;
    hasMultipleVersions: boolean | undefined;
    allowMultipleVersions: boolean | undefined;
}

export class JobDetailsDto implements IJobDetailsDto {
    customer: CustomerDto;
    jobAddress: AddressDto;
    title: string | undefined;
    serviceType: ProductDto;
    prefix: string | undefined;
    jobNumber: string | undefined;
    readonly fullJobNumber: string | undefined;
    readonly heading: string | undefined;
    readonly jobNumberDefined: boolean;
    description: string | undefined;
    internalNotes: string | undefined;
    assignedTo: EmployeeDto;
    readonly isUnassigned: boolean;
    scheduleLater: boolean;
    jobColor: string | undefined;
    jobId: number;
    createdBy: UserDto;
    jobStatus: JobStatuses;
    contactEmail: string | undefined;
    contactPhone: string | undefined;
    readonly jobStatusText: string | undefined;
    createDate: moment.Moment | undefined;
    lineItems: JobLineItemDto[] | undefined;
    jobVisits: JobVisitDto[] | undefined;
    jobForms: JobFormDto[] | undefined;
    attachedBy: string | undefined;
    attachedOn: moment.Moment | undefined;

    constructor(data?: IJobDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customer = _data["customer"] ? CustomerDto.fromJS(_data["customer"]) : <any>undefined;
            this.jobAddress = _data["jobAddress"] ? AddressDto.fromJS(_data["jobAddress"]) : <any>undefined;
            this.title = _data["title"];
            this.serviceType = _data["serviceType"] ? ProductDto.fromJS(_data["serviceType"]) : <any>undefined;
            this.prefix = _data["prefix"];
            this.jobNumber = _data["jobNumber"];
            (<any>this).fullJobNumber = _data["fullJobNumber"];
            (<any>this).heading = _data["heading"];
            (<any>this).jobNumberDefined = _data["jobNumberDefined"];
            this.description = _data["description"];
            this.internalNotes = _data["internalNotes"];
            this.assignedTo = _data["assignedTo"] ? EmployeeDto.fromJS(_data["assignedTo"]) : <any>undefined;
            (<any>this).isUnassigned = _data["isUnassigned"];
            this.scheduleLater = _data["scheduleLater"];
            this.jobColor = _data["jobColor"];
            this.jobId = _data["jobId"];
            this.createdBy = _data["createdBy"] ? UserDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.jobStatus = _data["jobStatus"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            (<any>this).jobStatusText = _data["jobStatusText"];
            this.createDate = _data["createDate"] ? moment(_data["createDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["lineItems"])) {
                this.lineItems = [] as any;
                for (let item of _data["lineItems"])
                    this.lineItems.push(JobLineItemDto.fromJS(item));
            }
            if (Array.isArray(_data["jobVisits"])) {
                this.jobVisits = [] as any;
                for (let item of _data["jobVisits"])
                    this.jobVisits.push(JobVisitDto.fromJS(item));
            }
            if (Array.isArray(_data["jobForms"])) {
                this.jobForms = [] as any;
                for (let item of _data["jobForms"])
                    this.jobForms.push(JobFormDto.fromJS(item));
            }
            this.attachedBy = _data["attachedBy"];
            this.attachedOn = _data["attachedOn"] ? moment(_data["attachedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): JobDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["jobAddress"] = this.jobAddress ? this.jobAddress.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["serviceType"] = this.serviceType ? this.serviceType.toJSON() : <any>undefined;
        data["prefix"] = this.prefix;
        data["jobNumber"] = this.jobNumber;
        data["fullJobNumber"] = this.fullJobNumber;
        data["heading"] = this.heading;
        data["jobNumberDefined"] = this.jobNumberDefined;
        data["description"] = this.description;
        data["internalNotes"] = this.internalNotes;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["isUnassigned"] = this.isUnassigned;
        data["scheduleLater"] = this.scheduleLater;
        data["jobColor"] = this.jobColor;
        data["jobId"] = this.jobId;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["jobStatus"] = this.jobStatus;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["jobStatusText"] = this.jobStatusText;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        if (Array.isArray(this.lineItems)) {
            data["lineItems"] = [];
            for (let item of this.lineItems)
                data["lineItems"].push(item.toJSON());
        }
        if (Array.isArray(this.jobVisits)) {
            data["jobVisits"] = [];
            for (let item of this.jobVisits)
                data["jobVisits"].push(item.toJSON());
        }
        if (Array.isArray(this.jobForms)) {
            data["jobForms"] = [];
            for (let item of this.jobForms)
                data["jobForms"].push(item.toJSON());
        }
        data["attachedBy"] = this.attachedBy;
        data["attachedOn"] = this.attachedOn ? this.attachedOn.toISOString() : <any>undefined;
        return data; 
    }

    clone(): JobDetailsDto {
        const json = this.toJSON();
        let result = new JobDetailsDto();
        result.init(json);
        return result;
    }
}

export interface IJobDetailsDto {
    customer: CustomerDto;
    jobAddress: AddressDto;
    title: string | undefined;
    serviceType: ProductDto;
    prefix: string | undefined;
    jobNumber: string | undefined;
    fullJobNumber: string | undefined;
    heading: string | undefined;
    jobNumberDefined: boolean;
    description: string | undefined;
    internalNotes: string | undefined;
    assignedTo: EmployeeDto;
    isUnassigned: boolean;
    scheduleLater: boolean;
    jobColor: string | undefined;
    jobId: number;
    createdBy: UserDto;
    jobStatus: JobStatuses;
    contactEmail: string | undefined;
    contactPhone: string | undefined;
    jobStatusText: string | undefined;
    createDate: moment.Moment | undefined;
    lineItems: JobLineItemDto[] | undefined;
    jobVisits: JobVisitDto[] | undefined;
    jobForms: JobFormDto[] | undefined;
    attachedBy: string | undefined;
    attachedOn: moment.Moment | undefined;
}

export class CreateJobNoteModel implements ICreateJobNoteModel {
    jobId: number;
    visitId: number | undefined;
    content: string | undefined;

    constructor(data?: ICreateJobNoteModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.visitId = _data["visitId"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreateJobNoteModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobNoteModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["visitId"] = this.visitId;
        data["content"] = this.content;
        return data; 
    }

    clone(): CreateJobNoteModel {
        const json = this.toJSON();
        let result = new CreateJobNoteModel();
        result.init(json);
        return result;
    }
}

export interface ICreateJobNoteModel {
    jobId: number;
    visitId: number | undefined;
    content: string | undefined;
}

export class JobNoteDto implements IJobNoteDto {
    noteId: number;
    content: string | undefined;
    jobId: number | undefined;
    visitId: number | undefined;

    constructor(data?: IJobNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.content = _data["content"];
            this.jobId = _data["jobId"];
            this.visitId = _data["visitId"];
        }
    }

    static fromJS(data: any): JobNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["content"] = this.content;
        data["jobId"] = this.jobId;
        data["visitId"] = this.visitId;
        return data; 
    }

    clone(): JobNoteDto {
        const json = this.toJSON();
        let result = new JobNoteDto();
        result.init(json);
        return result;
    }
}

export interface IJobNoteDto {
    noteId: number;
    content: string | undefined;
    jobId: number | undefined;
    visitId: number | undefined;
}

export class JobNoteDtoGenericResponse implements IJobNoteDtoGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: JobNoteDto;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: IJobNoteDtoGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? JobNoteDto.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobNoteDtoGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JobNoteDtoGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): JobNoteDtoGenericResponse {
        const json = this.toJSON();
        let result = new JobNoteDtoGenericResponse();
        result.init(json);
        return result;
    }
}

export interface IJobNoteDtoGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: JobNoteDto;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class CreateUserModel implements ICreateUserModel {
    firstName: string | undefined;
    lastName: string | undefined;
    createLogin: boolean;
    userName: string | undefined;
    isAdministrator: boolean;
    billRate: number;
    mobile: string | undefined;
    userColor: string | undefined;
    primaryPhone: string | undefined;
    email: string | undefined;
    employeeNumber: string | undefined;
    employeeType: EmployeeTypes;
    joiningDate: moment.Moment | undefined;
    createdBy: string | undefined;
    readonly roleName: string | undefined;

    constructor(data?: ICreateUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.createLogin = _data["createLogin"];
            this.userName = _data["userName"];
            this.isAdministrator = _data["isAdministrator"];
            this.billRate = _data["billRate"];
            this.mobile = _data["mobile"];
            this.userColor = _data["userColor"];
            this.primaryPhone = _data["primaryPhone"];
            this.email = _data["email"];
            this.employeeNumber = _data["employeeNumber"];
            this.employeeType = _data["employeeType"];
            this.joiningDate = _data["joiningDate"] ? moment(_data["joiningDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            (<any>this).roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): CreateUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["createLogin"] = this.createLogin;
        data["userName"] = this.userName;
        data["isAdministrator"] = this.isAdministrator;
        data["billRate"] = this.billRate;
        data["mobile"] = this.mobile;
        data["userColor"] = this.userColor;
        data["primaryPhone"] = this.primaryPhone;
        data["email"] = this.email;
        data["employeeNumber"] = this.employeeNumber;
        data["employeeType"] = this.employeeType;
        data["joiningDate"] = this.joiningDate ? this.joiningDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): CreateUserModel {
        const json = this.toJSON();
        let result = new CreateUserModel();
        result.init(json);
        return result;
    }
}

export interface ICreateUserModel {
    firstName: string | undefined;
    lastName: string | undefined;
    createLogin: boolean;
    userName: string | undefined;
    isAdministrator: boolean;
    billRate: number;
    mobile: string | undefined;
    userColor: string | undefined;
    primaryPhone: string | undefined;
    email: string | undefined;
    employeeNumber: string | undefined;
    employeeType: EmployeeTypes;
    joiningDate: moment.Moment | undefined;
    createdBy: string | undefined;
    roleName: string | undefined;
}

export class CreateUserModelGenericResponse implements ICreateUserModelGenericResponse {
    httpStatusCode: number;
    readonly hasError: boolean;
    isSuccess: boolean;
    entity: CreateUserModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;

    constructor(data?: ICreateUserModelGenericResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpStatusCode = _data["httpStatusCode"];
            (<any>this).hasError = _data["hasError"];
            this.isSuccess = _data["isSuccess"];
            this.entity = _data["entity"] ? CreateUserModel.fromJS(_data["entity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors.push(item);
            }
            this.errorType = _data["errorType"];
            this.actionReturnCode = _data["actionReturnCode"] ? ActionReturnCode.fromJS(_data["actionReturnCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserModelGenericResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserModelGenericResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpStatusCode"] = this.httpStatusCode;
        data["hasError"] = this.hasError;
        data["isSuccess"] = this.isSuccess;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorType"] = this.errorType;
        data["actionReturnCode"] = this.actionReturnCode ? this.actionReturnCode.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateUserModelGenericResponse {
        const json = this.toJSON();
        let result = new CreateUserModelGenericResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateUserModelGenericResponse {
    httpStatusCode: number;
    hasError: boolean;
    isSuccess: boolean;
    entity: CreateUserModel;
    errors: string[] | undefined;
    errorType: ErrorTypes;
    actionReturnCode: ActionReturnCode;
}

export class WeatherForecast implements IWeatherForecast {
    date: moment.Moment;
    temperatureC: number;
    readonly temperatureF: number;
    summary: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }

    clone(): WeatherForecast {
        const json = this.toJSON();
        let result = new WeatherForecast();
        result.init(json);
        return result;
    }
}

export interface IWeatherForecast {
    date: moment.Moment;
    temperatureC: number;
    temperatureF: number;
    summary: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}